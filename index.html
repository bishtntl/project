<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <h1>Backtracking</h1><br>
    <p>
        Backtracking is a form of recursion.

        The usual scenario is that you are faced with a number of option,and you must choose one of these. After you
        make your
        choice you will get a new set of option;just what set of option you get depends on what choice you made. This
        procedure
        is repeatednoverd over until you reacha final state. If you made a good squence of choice,you final state is a
        goal state;
        if you didn't,it isn't.</p>

    <p>Conceptually, you start at the root of a tree;the tree probably has some bad leaves and some bad leaves;though it
        may be
        thatthe leaves are all good or all bad.You want to get to a good leaf.At each node ,beginning with the root, you
        choose
        one of itschildren to move to,and you keep this up untill you get to a leaf.</p>

    <p> Suppose you get to a bad leaf.You can backtrack to continue the search for a good leaf by revoking your most
        recent choice,
        and trying out the next option in that set of option,revoke the choice that you got here,and tryanother choice
        at the node.If
        you end up at the root with no option left,there are no good leaves to be found.</p>


    This needs an example.

    <img src="./Image_root.png" alt="@"><br>
    <ol>
        <li> Starting at Root,your option are A and B.you choose A.</li><br>
        <li> At a,your option are C and D.you choose C.</li><br>
        <li> C is bad go back to A.</li><br>
        <li> A, you have alredy tried C and it failed Try D.</li><br>
        <li> D is bad.Go back to A.</li><br>
        <li> At A,you have no options left to try.Go back to Root.</li><br>
        <li> Root,you have alredy tired A.Try B.</li><br>
        <li> At B your options are E and F.Try E.</li><br>
        <li> E is good congratulation!</li>
    </ol>
    <p>In this example we drew a picture of a tree.The tree is an abstract model of the possible squences of choice we
        could make.There is also a data structure call a tree, but usually we don't have a data structure to tell us
        what choice we have.(If we do have an actual tree data structur,backtraking on it is called depth -first tree
        searching).</p>
    <hr><br><br>
    <h2>The blacktracking algorithm</h2>
    <font color="blue">
        <pre>

                boolean solve (Node n){
                    if n is a leaf node{
                        if the leaf is a goal node, return true
                        else return false
                    } else {
                        for each child c of n {
                            if solve(c)succeeds,return true
                        }
                        return false

                    }

                }

          </pre>
    </font>
    <p>

        notie that the algorithm is expressed as a boolean function.This is essential to understanding the algorithm.If
        solve(n) is true, that mean node n part of a solution--that is ,node n is one of the nodes on apath from the
        root to some
        goal node.we say that n is solvable. If solve(n)is false,than there is no path that includes n to any goal node.
    </p><br>

    <h3>How does it work?</h3>
    <ul type="disc">
        <li>If any child of n is solvable, than n is solvable.</li>
        <li>If no child of n is solvable, than n is not solvable.</li>
    </ul>

    <p>Hence, to decide whether any non leaf node n is solvable(part of a path to a goal node),all you have to do is
        test whether any
        child of n is solvabl. That is done recursively, on each child of n in the above code, this is done by the
        lines.
    </p>
    <font color="blue">
        <pre>
                for each child c of n{
                    if solve(c)succeeds, return true
                }
                return false

            </pre>
    </font>
    <p>
        Eventually the recursion will "bottom"out at a leasf node.If the leaf node is a goal node, it is solvable;if the
        leaf node is not a goal
        nodes,it is not solvable. This is our base case in the above code, this is done by the lines.

    </p>
    <font color="blue">
        <pre>
                    if n is a leaf node{
                        if leaf is goal node, return true
                        else return false

                    }

                </pre>


    </font>
    <p>
        The blacktracking algorithm is simple but important.You sould understand it thoroughly.Another way of stating it
        is a follows:


    </p>
    <ul type="disc">
        <li>
            <h3>To search a tree</h3>
        </li>
        <ol>
            <li>if the tree consists of a single leaf,test whetherit is goal node.</li>
            <li> Otherwise, search the subtrees until you find one containing a goal node or until you have
                searched them all unsuccessfully.</li>


        </ol>
    </ul><br>
    <h3>Non-recursive backtracking,using a slack</h3>
    <p>
        Backtracking is a rather typical recursive algorithm, and any recursive algorithm can be rewritten as a slack
        algorithm in fact,
        that is how your recursive algorithms are translated into machine or assembly language.</p>
    <font color="blue">
        <pre>
                        boolean solve(Node n){
                            put node n on the slack;
                            while the slack is not empty {
                                if the node at the top of the slack is a leaf{
                                    if it is a goal node,return true
                                    else pop it off the slack
                                }
                                else{
                                    if the node at the top of the slack has entried children
                                      push the next untired child onto the slack 
                                    else pop the node off the slack  

                            }
                         return false

                        }

                    </pre>

    </font>
    <p>Starting form the root, the only nodes that can be pushed onto the slack are the children of the node currently
        on the top of the
        stack and these are only pushed on one chlid at a time;hence,the nodes on the slack at all time describe a valid
        path in the
        tree.Nodes are removed from the slack only whr=en it is known that they have no goal nodes among their
        descendents.Therefore,
        if the root node gets removed(making the slack empty ),there ust have been no goal nodes at all,and no solution
        to the
        probleam.</p>

    <p>


        Whan the slack algorithm terminates successfully, the nodes on the slack form (in reverse order) a path from the
        root
        to a goal node.

    </p>

    <p>
        Similarly when the recursive algorithm find a goal node, the path information is embodied (in reverse order)in
        the sequence of
        recursive calls.Thus as the recursion unwinds,the path can be recoved one node at a time,by (for instance)
        printing the node
        at the current level,or storing it in an array.

    </p>
    <p>
        Here is the recusive blacktracking algorithm,modified slightly to print (in reverse order)the nodes along the
        successful path:
    </p>
    <font color="blue">
        <pre>
                        boolean solve(Node n ){
                            if n is a leaf node{
                                if the leaf is a goal node{
                                    print n 
                                    return true
                                }
                                else return false 
                        }else{
                            for each child c of n {
                                if solve (c)succeeds{
                                    print n 
                                    return true
                                }
                            }
                            return false
                        }
                    }
                    </pre>
    </font>
    <html>Keeping backtracking simple

    </html>
    <p>
        All of these version of the blacktracking algorithm are pretty simple, but when applied to a real probleam,they
        can get pretty
        clutterd up with details.Even determining whether the nodes is leaf can be complex:</p>

    <p>
        for example,if the path represents a sereis of moves in a chess end game probleam the leaves are the checkmate
        and stalemate
        solution.
    </p>
    <p>
        To keep the program clean, therefore,test like this should be buried in methods.In a chess game .for example,
        you could test
        whether a node is a leaf by writing a <b>gameOver method </b>(or you cloud even call it <b>isleaf)</b>.This
        method would encapsulate
        all the ugly detail of figuring out whether any possible move remain.
    </p>
    <p>
        Notice that the blacktracking altorithms require us to keep track, for each node on the current path, which of
        its children have
        beem tried already(so we don't have to try them again).In the above code we made this look simple by just saying
        <b>for each child c of n</b>
        In reality, it may be difficult to figure out what the possible children are, and there may be no obvious way to
        step through
        represents the arrangement after some piece has made a leagal move How do you find these children and how do you
        keep track of
        which one you are alredy examined?
    </p>
    <p>
        The most Straightforward way to keep track of which children of the node have been tried is as follows: Upon
        initial entry to the
        node (that is when you first get there from above), make a list of all its children. As you try each child take
        it off the list.When
        the list is empty, there are not remaining untired children anf you can return "failure".This is a simple
        approach,but it may require
        quite a lot of additional work.
    </p>
    <p>
        There is an eaiser way to keep track of which children have been tried.if you can defined an ordering on the
        children. if there is an
        odering, and you know which child you just tried,you can determine which child to try next.
    </p>
    <p>
        For example you might be able to number the children 1through n, and try them in numerical order.Then, if you
        just tried
        child k you know that you have already tried children 1through <b>k-1</b> and you have not yet tried children
        <b>k+1</b> through <b>n</b>
        or if you are trying to color a map with just with four color, you can always try <b>red first,then yellow, then
            green, then blue</b>.if child yellow
        fails you know to child green next. if you are searching a maze, you can try choices in the ordered
        left,straight,right<b>(or perhaps
            north,east,south,west).</b>

    </p>
    <p>
        it isn't always easy to find a simple way to order the children of a node <b>in the chess game example</b>.you
        might number your pieces
        (or perthaps the square of the board) and try them in numerical order bit it addnitonal each piece may also have
        several
        moves and these must also be odered.
    </p><br>
    <h3>Example:tree search</h3>
    <p>
        For starters, lest do the simpleast possible example of blacktracking, which is searching an actual tree.We will
        also use the
        simplest kind of tree, a binary tree.

    </p>
    <p>
        A binary tree is a data structure composed of nodes onre node is designated as the root node. Each node can
        reference(point
        to) zero,one,or two other nodes,which are called its children. The children are referred to as the left child
        and/or the right child
        Al nodes are reachable (by one or more step) from the root node and tere are no cycles for our purposes ,
        although this is not
        part of the defination of a binary tree, we will say that a node might or might not be a goal node and will
        contain its name.The first
        example in the paper (which we repeat here)shows a binary tree.
    </p>
    <p>
        Here's a defination of binary tree class:

    </p>
    <font color="blue">
        <pre>
                            public class binary tree{
                                binary tree left child=null;
                                binary tree right child=null;
                                boolean is goal node =false';
                                string name ;


                            Binary tree(string name, binary tree left binary tree right, boolean isGoalNode){
                               this name =name;
                               left child=left;
                               this is a GoalNoad=isGoalNode;
                            }

                          }

                        </pre>
    </font>
    <p>
        Next we will creat a Tree Search class and in it we will define a method make tree ()i which constructs the
        above binary tree.

    </p>
    <font color="blue">
        <pre>
                        static binary tree make tree(){
                            binary tree root a,b,c,d,e,f;
                            c=new binary tree ("c",null,null,false);
                            d=new binary tree ("D", null, null,false);
                            e=new binary tree ("E",null,null,true);
                            f=new binary tree ("F" null,null,false);
                            a=new binary tree ("A",c,d,false);
                            b=new binary tree ("B",e,f,false);
                            root = new binary tree("Root",a,b,false);
                            return root;
                        }
                    </pre>
    </font>
    <p>
        Here's main program to creat a binary tree and try to solve it:

    </p>
    <font color="blue">
        <pre>
                        public static void main (string args[]){
                            Binarytree tree = maketree();
                            systm.out.println(solvable(tree));

                        }
                    </pre>
    </font>
    <p>
        And finally,here's the recursive blacktracking routine to "solve" the binary tree by finding a goal node.

    </p>
    <font color="blue">
        <pre>
                        static boolean solvable (binary tree node){
                            /*1*/ if (node ==null)return false;
                            /*2*/ if (node.isGoalNode) return true;
                            /*3*/ if (solvable(node.leftchild)) return true;
                            /*4*/ if (solvabl(node.rightchild)) return true;
                            /*5*/ return false;
                        }
                    </pre>
    </font>
    <p>
        Here's what the numbered line are loading:
    <ol>
        <li>if we are given a null node,it's not solvable.This statement is so that we can all this method the children
            of a node, wihout
            first cracking whether those children actually exist. </li>
        <li>if the node we are given is a goal node return success. </li>
        <li>see if the left child of node is solvable,and if so .conclude the node is solvable .We will only fet to this
            line if node is not-full
            and is not a goal node, says to </li>
        <li>Do the same thing for the right child</li>
        <li>Since neither child of node is solvable,node itself is not solvable.</li>
    </ol>


    <p>
        This program runs correctly and produce the unenlightening result true.
    </p>

    <p>
        Each time we ask for another node, we have to check if it is null.In the above we put that check as the first
        thing in solvable. An
        alternative would be to check first whether each child exists,and recure only if they do.Here's that alternative
        version:

    </p>
    <font color="blue">
        <pre>
                            static boolean solvable (binary tree node){
                                
                                if(node.isGoalNode) return true;

                                if (node.leftchild !=null && solvable (node.leftchild))return true;

                                if(node.rightchild !=null && solvable(node.rightchild))return true;

                                return false;

                            }

                        </pre>

    </font>

    <p>
        I think the first version is simpler,but second version is slightly more efficient.

    </p>
    <h3>what are the children</h3>
    <p>
        one of the things that simplifies the above binary tree search that, at each choice point, you can ignore all
        the previous
        choices. previous choices don't give you any information about what you should do next;as far as you know both
        the left and the
        right child are possible solution.In many probleams ,however,you may be able to eliminate children
        immediately,without
        recursion.
    </p>
    <p>
        Consider,for example, the probleam of four-coloring a map it is a theorem of mathematics that any map on a
        plane, no matter
        how convoluted the countries are, can be colored with at most color, so that no two contries that share a border
        are the
        same color.
    </p>
    <p>
        To color a map, you choose a color for the first country, then the color for the second country, and so
        on,untill all counties are
        colored.
    </p>
    <p>
        There are two ways to do this:

    </p>
    <ul type="disc">
        <li> Method 1.Try each of the four possible colors, and recur.When you run out of countries,check whether you
            are at a goal node.</li>

        <li>Method 2.Try to choose colors that have not alreadybeen used for an adjacent country, and recur if and when
            you run out of
            countries, you have a successfuly colored the map.</li>
    </ul>
    <p>
        Lets apply each of these two methods to the probleam of coloring a checkerboard. This should be easily
        solvable,after all,a
        checkerboard needs only two color.
    </p>

    <b>boolean maplsOK()</b>
    <p>
        used by method 1 to check (at a leaf node) whether the entire map is colored correctly.

    </p>
    <b>boolean okTocolor(int row coulmn,int color)</b>
    <p>Used by method 2 to check at every node,whether there is an adjacent node alredy coloed with the given color.</p>

    <b>int[]nextRowAndColumn(int row,int column)</b>
    Used by both method to find the next "country" (actually,the row and column of the next suare on the chekerboard).

    <p>Here's the code for method 1:</p>
    <font color="blue">
        <pre>
                            boolean explore 1(int row,int column,int color)}{
                                if(row>=NUM_ROWS)return maplsOK();
                                map[row][column]=color;
                                for(int nextColor=Red;nextColor<=BLUE;nextcolor++){
                                    int[]next=nextRowAndcolumn(row,column);
                                    if(explore1(next[0],nextp[1],nextColor))return true;

                                }
                                 return false
                            }

                        </pre>
    </font>
    <p>And here's the code for method</p>
    <font color="blue">
        <pre>
                            boolean explore2(int row,int column,int color){
                            if(row>=NUM_ROWS)return true;
                            if(okToColor(row column color)){
                                map[row][column]=color;
                                for(intnext color=RED;nextcolor<=BLUE;nextcolor++){
                                    int[]next=nextRowAndColumn(row,column);
                                    if(explore2(next[0],next[1],nextcolor))return true;

                                }
                            }
                            return false
                        
                        }
                        </pre>
    </font>
    <p>
        Those appear preety similar,and you might think they are equally good. However, the timing information suggests
        otherwise.
    </p>

    <table border="1" align="center">
        <tr>
            <th></th>
            <th bgcolor="grey">2 by 3 map</th>
            <th bgcolor="grey">3 by 3 map</th>
            <th bgcolor="grey">3 by 4 map</th>
        </tr>
        <tr>
            <th bgcolor="grey">Method 1:</th>
            <td>60 ms.</td>
            <td>940 ms.</td>
            <td>60530ms.(1 minute)</td>
        </tr>
        <tr>
            <th bgcolor="grey">Method 2:</th>
            <td>0ms.</td>
            <td>0 ms.</td>
            <td>0 ms.</td>
        </tr>
    </table>
    <p>
        The zeros in the above table indicate times too short to measure(less than 1 millisecoand).Why this huge
        diffrence? Either of
        these methods could have exponential growth.Eliminating a node automatically all of its descendents, and this
        will often prevent
        exponential growth.Conversely by waiting to check until a leaf node is reached,eponential growthis practically
        guaranteed.if there
        is any way to eliminate children(reduse the set of choice),do so!
    </p>
    <h2>Debugging techniques</h2>
    <p>
        often our first try at a program doesn't work, and we need to debug it.Debuggers are helpful,but some time we
        need to fall
        back on inserting print statements.There are some tricks to making effective use of print statement.These trick
        can be
        applied to any program, but are especially useful when you are trying to debug recoursive routine.



    </p>
    <h3>Trick#1:Indent when you print method entries and exist</h3>


    <p>
        Often,the best debugging technique is to print every method call and return(or at least the most important
        ones).You probably
        want to print, for each method,eaht perameters it came in with, and what value it leaves with,however if you
        just print a long
        list of these it's hard to match up method exits with their corresponding entries.indenting to show the levelof
        nesting can help.
    </p>
    <h3>Trick#2:use specialized print method for debugging.</h3>
    <p>
        Don't clutter up your actual code more than you must Also,remember that the code inserted for debugging purposes
        can itself
        contain bugs,or (In the wrost case )can effact the results, so be very careful with it.

    </p>



    <p>
        Here's our debugging code.For this trivial program, tere's almost more debugging code than actual code, but it
        larger programs the proportion will be latter.

    </p>
    <font color="blue">
        <pre>
                            static string indent=""


                            static string name (Binary tree node){
                                if(node==null)return null;
                                else return node name;
                            }


                            static void enter(BinaryTree node){
                                System,out.println(indent + "Entering solvable(" +name(node)+ ")");
                                indent=indent +"|"
                            }


                            static boolean yes(Binery Tree node){
                                indent=indent.substing(3);
                                System.out.println(indent + "solvable"(" + name(node) + ")return true");
                                return true;

                            }

                            static boolean no(BinarytTee){
                                indent=indent.substring(3);
                                System.out.println(indent +"solvable(" + name(node)+ ")return false");
                                retuen false;                              
                            }

                        </pre>

    </font>
    <p>To use this code,we modify solvable as follows.</p>
    <font color="blue">
        <pre>
                             static boolean solvable(BinaryTree node){
                                enter(node);
                                if(node==null)return no(node);
                                if(node.isGoalNoad)return yes (node);
                                if (solvable(node.leftchild))return yes(node);
                                if (solvable(node.rightchild))return yes(node);

                                return no(node);

                             }

                        </pre>

    </font>
    <p>Add we get these result:</p>
    <pre>

                        Entering solvable (Root) 
                        | Entering solvable (A)
                        ||Entering solvable (C)
                        |||Entering sollvable(null)
                        |||solvable(null)returns false
                        |||Entering solvable (null)
                        |||solvable(null) returns false
                        ||solvable(C) return false
                        ||Entering solvable(D)
                        |||Entering solvable (null)
                        |||solvable(null)returns false
                        |||Entering solvable (null)
                        |||solvable(null)returns false
                        ||solvable (D)returns false
                        |solvable(A) retuns false
                        |Entering solvable false
                        |Entering solvable (B)
                        ||Entering solvable (E)
                        ||Solvable (E)returns true
                        |Solvable (B)returns true
                        Solvable (Root)returns true
                        true

                        </pre>

    <h3>Trick#3:Never discard your debugging statements</h3>
    <p>
        writing debugging statements is programing, too.Often it's as much work to debug the debugging statements a it
        is to debug
        the actual program is working. why throw this code away?
    </p>

    <p>
        Obviously,you don't want to print out all this debugging information from a program you are redy to submit (or
        to turn over to
        your manager).You could comment out your debugging calls,but that can be a lot of work what more ,in the above
        example,
        you would have to replace every return (yes) with return (true), and every return false.With all these changes,
        you might introduse new bugs into your program

    </p>
    <p>
        The simple solution is to make your debugging statements conditional. For example,
    </p>
    <font color="blue">
        <pre>
                                static final boolean debugging=false;



                                static void enter(BinaryTree node){
                                    if(debugging){
                                        System.out.println(indent + "Entering SSolvable(" +name(node) +")");
                                        indent=indent+"|";

                                    }

                                }
                                static boolean no(BinaryTree node){
                                    if(debugging){
                                        indent=indent.substring(3);
                                        system.out.println(indent+ "solvable(" +name(node)+")returns true");
                                    
                                    }
                                    returns true;

                                }
                            
                        



                                static boolean no(BinaryTree node){
                                    if(debugging){
                                        indent=indent.substring(3);
                                        system.out.println(indent +"solvable(" + name(node) +")returns false")

                                    }
                                    returns false;

                                }
                            </pre>
    </font>
    <p>
        In industry,actual programs often have multiple flag to control different aspects to debugging. Don't worry
        too much about making your code larger; modern compilers will notice that since the variable debugging is final,
        it can be never be true, and the controlled code will be discarded.
    </p>
    <h3>Trick#4: Create an Exception.</h3>
    <p>
        if an exception is thrown,you can get information about just where it happened by sending it the message
        printStack Trance (PrintStream).Since an Exception is an object like any other, you can create and throw your
        own exceptions
        However, Java programmers don't always realize that you can create an Exception without throwing it.For example
        , the following
        code.

    </p>


    <font color="blue">new Exception("checkpoint charlie").printStackTrace(System.out); </font>
    <p>will print out a massage sometime like this,and the program will then continue normally, That is the above code
        justact like a
        print statement.
    </p>
    <font color="blue">
        <pre>
                                        java.langExceptio:checkpoint charlie
                                        at TreeSearch.solvable(TreeSearch.java:53)
                                        at Treesearch.solvable(TreeSearch.java:57)
                                        at Treeseach. main(TreeSearch.java:72)
                                        at_SHELL38.run(at_SHELL38.java:16)
                                        at bluej.runtime.Exceserver.suspendExecution(Unkow source)
                                      </pre>

    </font>
    <h3>Example:cindy's puzzle</h3>
    <p> I call the following puzzle"cindy puzzle"for histrical reasons.You have some number n of block marble and the
        same number of white marbles, and you have a playing bord which contist simply of a line of 2n+1 space to put
        the marbles in.
        start with the black marbles at one(say, the left) the white marbles all the other end, snd a freespace in
        between.
    </p>
    <table border="1" align="center">

        <tr>
            <td><img src="./black-ball.png" width="100" alt="@"></td>
            <td><img src="./black-ball.png" alt="@" width="100"></td>
            <td width="100"><img src="" alt="">1</td>
            <td><img src="./white-ball.png" alt="@" width="100"></td>
            <td><img src="./white-ball.png" alt="@" width="100"></td>

        </tr>


    </table>
    <p>
        The goal is to reserve the position of the marble:

    </p>

    <table border="1" align="center">
        <tr>
            <td><img src="./white-ball.png" width="100" alt="@"></td>
            <td><img src="./white-ball.png  " alt="@" width="100"></td>
            <td width="100"><img src="" alt=""></td>
            <td><img src="./black-ball.png" alt="@" width="100"></td>
            <td><img src="./black-ball.png" alt="@" width="100"></td>

        </tr>

    </table>
    <ul type="disc">
        <b>The black marble can only move to the right,and the white marbles can only move to the left(no backing up.)at
            each move of
            marble can either.

        </b>
        <li>
            Move one space ahead, if that space is clear,or
        </li>
        <li>
            Jump ahead exactly one marble of the opposite color,if the space just beyond that marble is clear.
        </li>
        <p>
            For example, you could make the following squence of moves.
        </p>
        <ol>
            <table align="center" cellpadding="10px">

                <tr>
                    <th>Starting position</th>
                    <td>
                        <table border="1">
                            <tr>
                                <td><img src="./black-ball.png" width="100" alt="@"></td>
                                <td><img src="./black-ball.png" alt="@" width="100"></td>
                                <td width="100"><img src="" alt=""></td>
                                <td><img src="./white-ball.png" alt="@" width="100"></td>
                                <td><img src="./white-ball.png" alt="@" width="100"></td>
                            </tr>
                        </table>
                    </td>
                </tr>
                <tr>

                    <th>Black move ahead:</th>
                    <td>
                        <table border="1">
                            <tr>
                                <td><img src="./black-ball.png" width="100" alt="@"></td>
                                <td width="100"><img src="" alt=""></td>
                                <td width="100"><img src="./black-ball.png" width="100" alt=""></td>
                                <td><img src="./white-ball.png" alt="@" width="100"></td>
                                <td><img src="./white-ball.png" alt="@" width="100"></td>
                            </tr>

                        </table>
                    </td>
                </tr><br>
                <tr>
                    <th>White Jumps:</th>
                    <td>
                        <table border="1">
                            <tr>
                                <td><img src="./black-ball.png" width="100" alt="@"></td>
                                <td><img src="./white-ball.png" alt="@" width="100"></td>
                                <td width="100"><img src="./black-ball.png" alt="" width="100"></td>
                                <td width="100"><img src=""" alt=""></td>
                              <td><img src=" ./white-ball.png" alt="@" width="100"></td>

                            </tr>
                        </table>
                    </td>
                </tr><br>
                <tr>
                    <th>Black moves ahead:</th>
                    <td>
                        <table border="1">
                            <tr>
                                <td><img src="./black-ball.png" width="100" alt="@"></td>
                                <td><img src="./white-ball.png" alt="@" width="100"></td>
                                <td width="100"><img src="" alt=""></td>
                                <td><img src="./black-ball.png" alt="@" width="100"></td>
                                <td><img src="./white-ball.png" alt="@" width="100"></td>

                            </tr>
                        </table>
                    </td>
                </tr><br>
                <tr>
                    <th>Black Jump:</th>m
                    <td>
                        <table border="1">
                            <tr>
                                <td width="100"><img src="" alt=""></td>
                                <td><img src="./white-ball.png" alt="@" width="100"></td>
                                <td wid<img src="./black-ball.png" alt="@" width="100"></td>
                                <td><img src="./black-ball.png" alt="@" width="100"></td>
                                <td><img src="./white-ball.png" alt="@" width="100"></td>
                            </tr>
                        </table>
                    </td><br>
                </tr>
                <tr>
                    <th>White moves ahead: </th>
                    <td>
                        <table border="1">
                            <tr>
                                <td width="100"><img src="" alt=""></td>
                                <td><img src="./white-ball.png" alt="@" width="100"></td>
                                <td wid<img src="./black-ball.png" alt="" width="100"></td>
                                <td><img src="./black-ball.png" alt="" width="100"></td>
                                <td><img src="./white-ball.png" alt="" width="100"></td>
                            </tr>
                        </table>
                    </td>
                </tr><br>
                <tr>
                    <th>Stuck!</th>

                </tr>
            </table>
        </ol>

        <p>The blacktracking method is naed solvable and return a boolean. In solvable we shall need to
            check
            whether we are at a leaf
            which is this case mean a positiion from which no further moves are possible from wich no
            further moves
            are possible.This is not to easy.</p>

        <p>
            Now to the program.The main program will initialize the board.,and call a recurcive
            backtracking
            routine
            to attempt to sole the puzzle
            The backtracking routine will either succeed and print out a winning path, or it will fail,
            and
            will
            main program have to print out the bad
            news.
        </p>


        <p>
            The backtracking method is named solvable and a return a boolean.In sovable we shall need to
            check
            whether we are at a leaf,
            which in this case means a position from which no further moves are possible.This is not to
            easy.

        </p>



        <p>
            Each possible move will return in a new board postion, and these new board position are the
            childern of
            the current board
            position.Hence to find a children of a node(that is, or a board position),we need only find
            the
            possible
            move from that node.
            Remember that it is also highly desirable to find an ordring on these possible moves.

        </p>


        <p>
            First notice that of a marble has a move, that move is unique.if it can move ahead one
            square,than it
            cannnot jump,if it can jump.
            it cannot move ahead one square. This suggest that to find the possible move we might assign
            number to
            the marbles and check each marble
            in turn.When we have looked at the all marbles.We have looked at the all possible moves.This
            would
            require having a table to keep track
            to where each marble is, and somehow "marking" each marble with its number and searching the
            boad each
            time to find the marble we want
            Neither alternative is very attractive.

        </p>




        <p>
            Next, noice that for a given board position,each marbles occupies a unique space.Hence
            instead
            of
            talking about moving a
            particular marble,we can talk about moving the marble in a partical space.if a move is
            possible
            form a
            given space, than that must
            be the only move possible from the space because if the marble in that space has a move,it
            is
            unique.There is a slight complication because
            not every space contains a marble but atleast the space (unlike the maarbles)stay in one
            place.

        </p>



        <p>
            <b>Now we have simpler ordering to moves to use inour program.Just check in, in order, the
                2n+1
                spaces
                of the board.
                For each space, either zero or one moves is possible.With this understanding,we can
                write a
                boolean
                method canMove(int[]
                board int possible). which determines whether a moves is possible from the given
                possition.


            </b>
        </p>


        <ul type="disc">
            <li>
                if the positin is empty, no move is possible.

            </li>
            <li>
                if the position contains a black marble,the method checks for a move or jump to the
                right.

            </li>
            <li>
                if the position contains a white marble, the method checks for a move or jump to the
                left.
            </li>

        </ul>



        <p>
            We write another method <b>int[] makeMoves (int[] oldBoard,int positiion).</b>that will take
            a
            board,and
            a position, make a moves from
            that position, and return as its value a new board (we could write this somewhat more
            efficiently by
            changing the old board,
            rather than creating a new one but here we are more concerned with simplicity.)in technical
            jargon,makeMoves is "applicative"
            rather than "mutative".
        </p>

        <p>
            Along with <b>canMove and makeMove,</b> we are using method<b>puzzle solve and
                printBoard</b>
            with
            meanings that
            should be obvious.
        </p>

        <font color="blue">
            <pre>
                                                boolean solvable(int[]board{

                                                     if(puzzleSolved(board)){

                                                    return true

                                                    }

                                                    For(int psition=0; position< BOARD_SIZE;position++){

                                                        if(canMove(board position)){

                                                                int[]newBoard= makeMove(board, positon);

                                                                if(solvable(new board)){

                                                                    printBoard (new board);

                                                                    return true;
                                                                }

                                                        }

                                                    }

                                                    return false;

                                                }
                                        </pre>

        </font>

        <p>
            Along with canMove and makeMove, we are using methods puzzleSolved and print board with
            meanings
            that
            should be obvious.

        </p>
        <p>
            Here is some output from the program.

        </p>

        <ol reversed type="1" start="16 " >



            <li style="color: blue;"><span style="color: black;"><b>WHITE WHITE WHITE _______ BLACK
                        BLACK BLACK</b></span></li>
            <li style="color: blue;"><span style="color: black;"><b>WHITE WHITE WHITE BLACK _______
                        BLACK
                        BLACK</b></span></li>
            <li style="color: blue;"><span style="color: black;"><b>WHITE WHITE _______ BLACK WHITE
                        BLACK
                        BLACK</b></span></li>
            <li style="color: blue;"><span style="color: black;"><b>WHITE _______ WHITE BLACK WHITE
                        BLACK
                        BLACK</b></span></li>
            <li style="color: blue;"><span style="color: black;"><b>WHITE BLACK WHITE _______ WHITE
                        BLACK
                        BLACK</b></span></li>
            <li style="color: blue;"><span style="color: black;"><b>WHITE BLACK WHITE BLACK WHITE
                        _______
                        BLACK</b></span></li>
            <li style="color: blue;"><span style="color: black;"><b>WHITE BLACK WHITE BLACK WHITE BLACK
                        _______</b></span></li>
            <li style="color: blue;"><span style="color: black;"><b>WHITE BLACK WHITE BLACK _______
                        BLACK
                        WHITE</b></span></li>
            <li style="color: blue;"><span style="color: black;"><b>WHITE BLACK _______ BLACK WHITE
                        BLACK
                        WHITE</b></span></li>
            <li style="color: blue;"><span style="color: black;"><b>_______ BLACK WHITE BLACK WHITE
                        BLACK
                        WHITE</b></span></li>
            <li style="color: blue;"><span style="color: black;"><b>BLACK _______ WHITE BLACK WHITE
                        BLACK
                        WHITE</b></span></li>
            <li style="color: blue;"><span style="color: black;"><b>BLACK BLACK WHITE _______ WHITE
                        BLACK
                        WHITE</b></span></li>
            <li style="color: blue;"><span style="color: black;"><b>BLACK BLACK WHITE BLACK WHITE
                        _______
                        WHITE</b></span></li>
            <li style="color: blue;"><span style="color: black;"><b>BLACK BLACK WHITE BLACK _______
                        WHITE
                        WHITE</b></span></li>
            <li style="color: blue;"><span style="color: black;"><b>BLACK BLACK _______ BLACK WHITE
                        WHITE
                        WHITE</b></span></li>
            <li style="color: blue;"><span style="color: black;"><b>BLACK BLACK BLACK _______ WHITE
                        WHITE
                        WHITE</b></span></li>




        </ol>

        <p>
            Notice the solution is given in reverse order:Black starts out on the left and White on the
            the
            right,
            as in the last
            line.I've added line numbers to the actual output in order to emphasize this
            point.Blacktracking
            always
            produces its
            results (squences of choices) in reverse order;is it up to you, the programmer, to reverse
            the
            results
            again to get
            them in the correct order.

        </p>












































































































































































</body>

</html>